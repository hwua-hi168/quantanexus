{{- if and .Values.certManager.enabled (not .Values.ingress.tlsManual) }}
apiVersion: batch/v1
kind: Job
metadata:
  name: quantanexus-ca-sync
  namespace: {{ .Values.global.namespace | default "quantanexus" }}
  labels:
    app: quantanexus-ca-sync
    {{- include "quantanexus.labels" . | nindent 4 }}
  annotations:
    # 使用 Helm hook 在安装前执行，但权重比 RBAC 大，确保 RBAC 先创建
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-creation-hook
spec:
  template:
    metadata:
      labels:
        app: quantanexus-ca-sync
    spec:
      serviceAccountName: quantanexus-cert-sync
      restartPolicy: OnFailure
      containers:
      - name: ca-sync
        image: bitnami/kubectl:latest
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "正在从 {{ .Values.certManager.rootCA.sourceNamespace }} 命名空间同步根证书..."
          
          # 等待 ServiceAccount 和权限就绪（短暂延迟）
          sleep 5
          
          # 检查目标命名空间是否存在，如果不存在则创建
          if ! kubectl get namespace {{ .Values.global.namespace }} &>/dev/null; then
            echo "命名空间 {{ .Values.global.namespace }} 不存在，正在创建..."
            kubectl create namespace {{ .Values.global.namespace }}
          fi
          
          # 检查源 Secret 是否存在
          if kubectl get secret {{ .Values.certManager.rootCA.sourceSecretName }} -n {{ .Values.certManager.rootCA.sourceNamespace }} &>/dev/null; then
            echo "找到 {{ .Values.certManager.rootCA.sourceSecretName }}，开始同步..."
            
            # 获取证书数据
            CERT_DATA=$(kubectl get secret {{ .Values.certManager.rootCA.sourceSecretName }} -n {{ .Values.certManager.rootCA.sourceNamespace }} -o jsonpath='{.data.tls\.crt}')
            
            if [ -n "$CERT_DATA" ]; then
              # 解码证书数据
              echo "$CERT_DATA" | base64 -d > /tmp/root-ca.crt
              
              # 验证证书文件
              if [ -s /tmp/root-ca.crt ]; then
                echo "证书文件有效，正在创建 Secret..."
                
                # 创建或更新目标 Secret
                kubectl create secret generic {{ .Values.certManager.rootCA.targetSecretName }} \
                  -n {{ .Values.global.namespace }} \
                  --from-file=ca.crt=/tmp/root-ca.crt \
                  --dry-run=client -o yaml | kubectl apply -f -
                  
                echo "根证书同步完成"
                
                # 验证创建的 Secret
                if kubectl get secret {{ .Values.certManager.rootCA.targetSecretName }} -n {{ .Values.global.namespace }} &>/dev/null; then
                  echo "✅ Secret {{ .Values.certManager.rootCA.targetSecretName }} 创建成功"
                else
                  echo "❌ Secret 创建失败"
                  exit 1
                fi
              else
                echo "❌ 证书文件为空或无效"
                exit 1
              fi
            else
              echo "❌ 无法获取证书数据"
              exit 1
            fi
          else
            echo "❌ 在 {{ .Values.certManager.rootCA.sourceNamespace }} 命名空间中未找到 {{ .Values.certManager.rootCA.sourceSecretName }}"
            echo "⚠️  将创建空的证书 Secret 作为占位符"
            kubectl create secret generic {{ .Values.certManager.rootCA.targetSecretName }} \
              -n {{ .Values.global.namespace }} \
              --from-literal=ca.crt="placeholder-certificate" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          
          # 清理临时文件
          rm -f /tmp/root-ca.crt
{{- end }}